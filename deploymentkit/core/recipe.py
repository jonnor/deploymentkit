
import os.path

import yaml

import deploymentkit

"""Target independent package recipe

This is similar to what the native GNU/Linux packaging systems use
(.spec, .dsc, PKGBUILD, ebuild) but different in two significant ways:

- Metadata is specified in a target independent way.
- The format is designed to be easy to access programatically.
- The format is declarative.

This target independent recipe is transformed into
a target specific recipe by DeploymentKit.

Mapping the metadata declarations to actions used to build the software
is the responsiblity of the target implementation inside DeploymentKit.

Programatic access is important so that it can be manipulated with
other tools, for instance graphically by the user in a
integrated development environment or generated by information
already found in the build-system.

Dependencies are specified using for instance:
- pkg-config
- dbus
- executable
"""

def format_defaults(format_definition):
    defaults = {}

    for attribute, definition in format_definition.items():
        mandatory, value_type, default_value, description, example_value = definition

        defaults[attribute] = default_value

    return defaults

def format_mandatory_attributes(format_definition):
    attributes = []

    for attribute, definition in format_definition.items():
        mandatory, value_type, default_value, description, example_value = definition

        if mandatory:
            attributes.append(attribute)

    return attributes

def format_optional_attributes(format_definition):
    attributes = []

    for attribute, definition in format_definition.items():
        mandatory, value_type, default_value, description, example_value = definition

        if not mandatory:
            attributes.append(attribute)

    return attributes

def format_example(format_definition):
    example = {}
    for key, value in format_definition.items():
        example[key] = format_definition[key][-1]
    return example

def format_documentation(format_definition):
    # Literal documentation
    metadata_documentation = ''
    doc_lines = []
    def doc_attribute_str(attribute):
       mandatory, value_type, default_value, description, example = format_definition[attribute]
       return '\t%s (%s): %s' % (attribute, value_type, description)

    # Header
    doc_lines.append("The package metadata format used by DeploymentKit is based on YAML.")
    doc_lines.append("")
    doc_lines.append("")

    # Mandatory attributes
    doc_lines.append('The following attributes are mandatory:')
    for attribute in format_mandatory_attributes(format_definition):
        doc_lines.append(doc_attribute_str(attribute))

    # Optional attributes
    doc_lines.append("")
    doc_lines.append('The following attributes are optional:')
    for attribute in format_optional_attributes(format_definition):
        doc_lines.append(doc_attribute_str(attribute))

    metadata_documentation = '\n'.join(doc_lines)

    # Example
    metadata_documentation += "\n\nExample:\n\n"
    metadata_documentation += yaml.dump(format_example(format_definition))

    return metadata_documentation

format_definition = {
    # 'Attribute': (mandatory, value_type, default_value,
    #           description, example_value)
    'Name': (True, 'string', '',
            'Name of the software', 'foo'),

    'Version': (True, 'string', '0',
            'Version of the software', '1.0.0'),

    'ReleaseVersion': (True, 'string', '0',
            'Version of the package', '1'),

    'BriefDescription': (True, 'string', '',
            'Short description of the software',
            'foo is a well known example software'),

    'Description': (False, 'string', '',
            'Longer description of the software',
            'foos amazing capabilities and qualities has led it to become ubiquitous'),

    'URL': (True, 'string', 'http://example.org',
            'The homepage of the software',
            'http://www.example.org/foo'),

    'BuildSystemType': (True, 'string', [],
            'The build system used. Supported: autotools',
            'autotools'),

    'Licenses': (True, 'list-of-strings', [],
            'The licenses this software is under',
            'GPL'),

    'Dependencies': (True, 'list-of-strings', [],
            'The runtime dependencies of this software',
            ["pkg-config:glib-2.0","executable:gcc"]),

    'BuildDependencies': (True, 'list-of-strings', [],
            'The runtime dependencies of this software',
            ["pkg-config:glib-2.0","executable:gcc"]),
}

class PackageMetadata(object):
    
    # TODO: Rename to GenericRecipeFormat
    
    # FIXME: Formalize supported values
    # TODO: some more could probably be optional?
    # TODO: define default value for optional attributes
    # TODO: define a sorting order (for use in the documentation)

    definition = format_definition
    default = format_defaults(format_definition)
    example = format_example(format_definition)

    __doc__ = format_documentation(format_definition)

    # Disjunct sets
    mandatory_attributes = set(format_mandatory_attributes(format_definition))
    optional_attributes = set(format_optional_attributes(format_definition))


class PackageRecipe(object):
    """ """

    # TODO: rename to GenericRecipe

    def __init__(self):
        self._data = dict(PackageMetadata.default)

    def load(self, mapping):
        """Load the metadata from @mapping."""

        # TODO: warn on unknown input attributes
        # TODO: verify types of input attributes

        self._data = dict(PackageMetadata.default)
        self._data.update(mapping)

    def load_from_string(self, string):
        """Load the metadata from @string in YAML format."""
        mapping = yaml.load(string)
        self.load(mapping)

    def load_from_file(self, filepath):
        file_contents = open(filepath).read()
        self.load_from_string(file_contents)

    def get_data(self):
        # Return copy so that it cannot be mutated by others
        return dict(self._data)
    data = property(get_data)


class TargetRecipe(object):
    """Target specific recipe."""
    
    def __init__(self):
        pass

    def files(self):
        pass

    def write_to_directory(self, path):
        output_prefix = path
        output_files = self.files()

        for filename, file_content in output_files.items():
            if not os.path.exists(output_prefix):
                os.makedirs(output_prefix)
            f = open(os.path.join(output_prefix, filename), 'w')
            f.write(file_content)
            f.close()
