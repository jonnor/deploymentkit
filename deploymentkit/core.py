
import os.path

import yaml

import deploymentkit

"""Target independent package recipe

This is similar to what the native GNU/Linux packaging systems use
(.spec, .dsc, PKGBUILD, ebuild) but different in two significant ways:

- Metadata is specified in a target independent way.
- The format is designed to be easy to access programatically.
- The format is declarative.

This target independent recipe is transformed into
a target specific recipe by DeploymentKit.

Mapping the metadata declarations to actions used to build the software
is the responsiblity of the target implementation inside DeploymentKit.

Programatic access is important so that it can be manipulated with
other tools, for instance graphically by the user in a
integrated development environment or generated by information
already found in the build-system.

Dependencies are specified using for instance:
- pkg-config
- dbus
- executable
"""


# FIXME: Formalize supported values
# TODO: some more could probably be optional?
# TODO: define a sorting order (for use in the documentation)
metadata_format = {
    # 'Attribute': (mandatory, value_type, default_value,
    #           description, example_value)
    'Name': (True, 'string', '',
            'Name of the software', 'foo'),

    'Version': (True, 'string', '0',
            'Version of the software', '1.0.0'),

    'ReleaseVersion': (True, 'string', '0',
            'Version of the package', '1'),

    'BriefDescription': (True, 'string', '',
            'Short description of the software',
            'foo is a well known example software'),

    'Description': (False, 'string', '',
            'Longer description of the software',
            'foos amazing capabilities and qualities has led it to become ubiquitous'),

    'URL': (True, 'string', 'http://example.org',
            'The homepage of the software',
            'http://www.example.org/foo'),

    'BuildSystemType': (True, 'string', [],
            'The build system used. Supported: autotools',
            'autotools'),

    'Licenses': (True, 'list-of-strings', [],
            'The licenses this software is under',
            'GPL'),

    'Dependencies': (True, 'list-of-strings', [],
            'The runtime dependencies of this software',
            ["pkg-config:glib-2.0","executable:gcc"]),

    'BuildDependencies': (True, 'list-of-strings', [],
            'The runtime dependencies of this software',
            ["pkg-config:glib-2.0","executable:gcc"]),
}

# Generated from above definition
mandatory_attributes = [] # actually a set, see below
optional_attributes = [] # actually a set, see below
default_metadata = {}
for attribute, definition in metadata_format.items():
    mandatory, value_type, default_value, description, example_value = definition

    default_metadata[attribute] = default_value

    if mandatory:
        mandatory_attributes.append(attribute)
    else:
        optional_attributes.append(attribute)

# Disjunct sets
mandatory_attributes = set(mandatory_attributes)
optional_attributes = set(optional_attributes)

# Literal documentation
metadata_documentation = ''
doc_lines = []
def doc_attribute_str(attribute):
   mandatory, value_type, default_value, description, example = metadata_format[attribute]
   return '\t%s (%s): %s' % (attribute, value_type, description)

# Header
doc_lines.append("The package metadata format used by DeploymentKit is based on YAML.")
doc_lines.append("")
doc_lines.append("")
# Mandatory attributes
doc_lines.append('The following attributes are mandatory:')
for attribute in mandatory_attributes:
    doc_lines.append(doc_attribute_str(attribute))

# Optional attributes
doc_lines.append("")
doc_lines.append('The following attributes are optional:')
for attribute in optional_attributes:
    doc_lines.append(doc_attribute_str(attribute))

metadata_documentation = '\n'.join(doc_lines)

example = {}
for key, value in metadata_format.items():
    example[key] = metadata_format[key][-1]

metadata_documentation += "\n\nExample:\n\n"
metadata_documentation += yaml.dump(example)


class PackageRecipe(object):
    """ """

    def __init__(self):
        self.data = {}

    def output_target_recipe(self, target_platform=None):
        """Generate the target-specific recipe.
        Returns a mapping {"filename": "content"}"""
        
        if not target_platform:
            # TODO: option to autodetect the current platform
            target_platform = deploymentkit.supported_targets['ArchLinux']

        return target_platform.generate_recipe(self)

"""Target platform

"""

# TODO: Use same platform identifiers as PackageKit? Or OBS?
supported_platforms = {}

class TargetPlatform(object):
    """Interface class for a target platform."""
    
    def __init__(self):
        pass

    def generate_recipe(self, pkg_recipe):
        """Generate a target specific package recipe from the generic @pkg_recipe
        To be implemented by a specific target platform."""
        pass


def generate_recipe(input_file, output_prefix, target_id):
	"""Generate the target-specific package recipie from
	the YAML @input_file, and write the files to the path @output_prefix."""
	
	pkg = PackageRecipe()
	pkg.data = yaml.load(open(input_file).read())

	if target_id:
	    target = deploymentkit.supported_targets[target_id]
	else:
	    target = None # Autodetect
	output_files = pkg.output_target_recipe(target)
	
	for filename, file_content in output_files.items():
		if not os.path.exists(output_prefix):
		    os.makedirs(output_prefix)
		f = open(os.path.join(output_prefix, filename), 'w')
		f.write(file_content)
		f.close()
	
