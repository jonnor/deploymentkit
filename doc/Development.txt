Random bits of documentation regarding the
development of DeploymentKit.

= Foundational ideas =
Ideas that form the basis of the project.

- Software is worthless if it does not reach its target users
- Packaging and deployment are ESSENTIAL to a software project, not secondary
- Users are on multiple, different target platforms, and will continue to be
- Software authors use, and will continue to use a plenthora of different build systems
- Inventing a one-deployment-system-to-rule-them-all unrealistic

= Design =
- A target-independent package recipe is converted by DeploymentKit
into the required specific package recipe for a given target.

The specific package recipie is then used together with a native,
or cross-platform/cross-build toolchain to build the files the user will install.
This allows software developers to deploy for a number of platforms
without having to know and go through the details of deploying for each and every one.

- The package recipe format is declarative, using a standardized, machine-parsable format

The declarative nature of the package recipe enables it to be manipulated
programatically. For example it can be generated by the build system used,
or it can be integrated into IDE's and other graphical tools.

= Development principles =
- Enable and encourage others to contribute
- Contribute changes to related projects where appropriate,
istead of working around the problems
- Reuse as much as possible of existing code and projects
- Use real, non-trivial software projects as test subjects
- Automated testing of all supported features on supported target platforms
- Dogfooding, use in own projects
- Focus first on simple but high-impact use-cases
- Documentation lives as close to the relevant code as possible

= Usecases/Personas =
- Third-party application developers
Primary targets.

- Upstream open source developers
Application developers: Primary targets.
Libary/framework developers: Secondary targets.

- Downstream packagers
Tertiary targets.

= Notes =

- Building for multiple targets is a common, or the most common usecase
- Software authors will often, or typically want to deploy on targets different from
their development system.
- The generated target-specific recipe will depend on toolchain/builder used
For instance OBS likes its debian and spec files in a slightly different way than native toolchains. 

- There are different ways to build and deploy a given software on a given target
Examples on Linux:
    .run-style binary install wizards, 
    .bin-style single-file executables,
    binary tarball archives,
    native distro packaging, 
    native distro packaging combined with bundling

Examples on Windows:
    .exe-style wizard or .msi file
    Native mingw32 toolchain, or Linux cross-compile (possibly with RPM), or
    native Windows toolchain
    NSIS, MS Visual Studio, wizard toolchain
    
Examples on Mac OSX:
    .app bundles
    .dmg disk images

A sane default needs to be used for a given target, but consumers should
be able to override/customize the build when needed.

- Consumers might want a binary package that works across similar targets,
or one package optimized for each.

- How to specify targets?

Family, Variant, Architecture, Version ?
linux-fedora-x86_64-15
linux-archlinux-x86-2011.11.23
windows-mobile-armv7-8
windows-desktop-x86-xp
mac-osx-x86-10.6
mac-ios-armv7-4
