Random bits of documentation regarding the
development of DeploymentKit.

= Foundational ideas =
Ideas that form the basis of the project.

- Software is worthless if it does not reach its target users
- Packaging and deployment are ESSENTIAL to a software project, not secondary
- Users are on multiple, different target platforms, and will continue to be
- Software authors use, and will continue to use a plenthora of different build systems
- Inventing a one-deployment-system-to-rule-them-all unrealistic

= Design =
- A target-independent package recipe is converted by DeploymentKit
into the required specific package recipe for a given target.

The specific package recipie is then used together with a native,
or cross-platform/cross-build toolchain to build the files the user will install.
This allows software developers to deploy for a number of platforms
without having to know and go through the details of deploying for each and every one.

- The package recipe format is declarative, using a standardized, machine-parsable format

The declarative nature of the package recipe enables it to be manipulated
programatically. For example it can be generated by the build system used,
or it can be integrated into IDE's and other graphical tools.

= Development principles =
- Enable and encourage others to contribute
- Contribute changes to related projects where appropriate,
istead of working around the problems
- Reuse as much as possible of existing code and projects
- Use real, non-trivial software projects as test subjects
- Automated testing of all supported features on supported target platforms
- Dogfooding, use in own projects
- Focus first on simple but high-impact use-cases
- Documentation lives as close to the relevant code as possible

= Target Users =
Based on the Personas defined below.

Primary targets:
    - C the commercial application developer.
    - Martin the open source application developer.

Secondary targets:
    - Øyvind the open source library/framework developer.

Tertiary targets:
    - Lennart the system component developer.
    - P the Linux-distro packager.

    If they want to make use of the software and find it useful, good.
    However, no core development time will be spent on this group
    at this time. Contributed features for this target group are accepted
    if: the bugfixes have no disadvantage for higher priority groups
    or the additional feature also makes sense for a higher priority group.


Non-targets:
    - T the open source software tester.
    Not a target user as the software developer will do the deployment.
    This will hopefully make Ts job easier, and remove the need for
    him to setup and mainain a development system.

= Personas =

=== C the commercial application developer ===
C is paid to write the software he does, and often does not
use this software himself.

C choses the features of the software and platforms to support
based on how the expected finanical income that gives compared to
the effort required.

C uses an SDK+IDE provided with the system, and expects
packaging to be done with minimum manual work.


Based on: TODO

=== Martin the open source application developer ===

Martin writes his software because he thinks it is a fun and
rewarding thing to do. He is also on of the primary users
of his application.
Martin would like for it to be used by
other people as well, but does not want to work actively on
platforms that he himself does not use. He relies on contributions
from others to make the software run well on those platforms. These
are others like himself, or P the Linux-disto packager and T the open
source software tester.
When testing custom versions of own code, Martin does think the
effort of packaging is worth it over just installing/running directly.

Martin very often uses libraries written by Øyvind.

Based on: Martin Renold, MyPaint maintainer

=== Øyvind the open source library/framework developer ===
Øyvind gets paid to develop some of the libraries he does, but not all.

While some of the libraries Øyvind has developed are included into
shipped systems by default, most are not. They are most often packaged by P.
Øyvind makes his software available as source code on his website,
and does not want to spend effort on packaging for other people.
When testing custom versions of own code, Øyvind does think the
effort of packaging is worth it over just installing/running directly.

Øyvinds libraries are often used by Martin. They are sometimes also
used by X, though this is more rare.

Based on: Øyvind Kolsås, GEGL maintainer

=== Lennart the Linux system component developer ===
Lennarts is paid to write his software and writes it with
his companies usecase at the forefront of his mind.
He likes to make software that is useful also for other systems
but considers it someone elses job to adapt and improve it
for those systems. Some of software will be platform-dependent
and will not support fundamentally different types of systems.

Lennarts software is shipped as part of a system install,
and are often used by many other central components in the system.
The other components the software uses will also be shipped with the system.

Based on: Lennart Poettering, systemd maintainer

=== P the Linux-distro packager ===
P wants to contributes to the open source, and does this
by creating packages for the software that Øyvind,
Martin and Lennart writes. P can write scripts for automating task and
simple applications, but does not do this very often.

P thinks that using the packing system for his favorite distribution is
quick and easy, and all packaging issues would be fixed if everyone
just switched to this system and learned it.

Based on: TODO

=== T the open source software tester ===
T contributes

T mostly tests the applications Martin develops, but sometimes also
tests the libraries that Øyvind developes. On rare occations he
also reports bugs in the system software Lennart writes.

T does not like setting up, maintaining and using a development system,
but often does it because it is neccesary to be able to build and test custom
versions of the software.

T often does not use a packaging system when testing. He does not
understand them very well and when Martin and Øyvind don't use them,
why should he?

Based on: TODO


= Usecases =

Each usecase should have:
- The usecase
- Current solutions
- Issues with current solutions
- Proposed new solution
- Ideas/details for implementation

= Notes =

- Building for multiple targets is a common, or the most common usecase
- Software authors will often, or typically want to deploy on targets different from
their development system.
- The generated target-specific recipe will depend on toolchain/builder used
For instance OBS likes its debian and spec files in a slightly different way than native toolchains.

- There are different ways to build and deploy a given software on a given target
Examples on Linux:
    .run-style binary install wizards,
    .bin-style single-file executables,
    binary tarball archives,
    native distro packaging,
    native distro packaging combined with bundling

Examples on Windows:
    .exe-style wizard or .msi file
    Native mingw32 toolchain, or Linux cross-compile (possibly with RPM), or
    native Windows toolchain
    NSIS, MS Visual Studio, wizard toolchain

Examples on Mac OSX:
    .app bundles
    .dmg disk images

A sane default needs to be used for a given target, but consumers should
be able to override/customize the build when needed.

- Consumers might want a binary package that works across similar targets,
or one package optimized for each.

- How to specify targets?

Family, Variant, Architecture, Version ?
linux-fedora-x86_64-15
linux-archlinux-x86-2011.11.23
windows-mobile-armv7-8
windows-desktop-x86-xp
mac-osx-x86-10.6
mac-ios-armv7-4
